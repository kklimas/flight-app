create table t_reservation
(
    id        int generated by default as identity
        primary key,
    flight_id int,
    date      timestamp default CURRENT_DATE,
    user_id   int,
    status    char      default 'N',
    constraint fk_flight foreign key (flight_id) references t_flight (id),
    constraint fk_user foreign key (user_id) references t_user (id)
);

create table t_reservation_log
(
    id             int generated by default as identity primary key,
    log_date       timestamp default current_date,
    reservation_id int,
    status         char,
    constraint fk_reservation foreign key (reservation_id) references t_reservation (id)
);

CREATE OR REPLACE FUNCTION f_add_reservation_log()
    RETURNS TRIGGER AS
$$
BEGIN
    IF NEW.status = 'N' THEN
        UPDATE t_flight t
        SET no_available_places = t.no_available_places - 1
        WHERE t.id = NEW.flight_id;
    END IF;
    IF NEW.status = 'C' THEN
        UPDATE t_flight t
        SET no_available_places = t.no_available_places + 1
        WHERE t.id = NEW.flight_id;
    END IF;
    INSERT INTO t_reservation_log (reservation_id, status)
    VALUES (NEW.id, NEW.status);
    RETURN NEW;
END
$$
    LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER tr_add_reservation_log
    AFTER INSERT OR UPDATE
    ON t_reservation
    FOR EACH ROW
EXECUTE FUNCTION f_add_reservation_log();

CREATE OR REPLACE FUNCTION f_forbid_deletion()
    RETURNS TRIGGER AS
$$
BEGIN
    RAISE EXCEPTION 'Cannot delete rows from this table.';
END
$$
    LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER tr_forbid_reservation_deletion
    BEFORE DELETE
    ON t_reservation_log
    FOR EACH ROW
EXECUTE FUNCTION f_forbid_deletion();

CREATE OR REPLACE TRIGGER tr_forbid_log_deletion
    BEFORE DELETE
    ON t_reservation_log
    FOR EACH ROW
EXECUTE FUNCTION f_forbid_deletion();